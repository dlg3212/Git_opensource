1. 리다이렉션
- 표준 스트림이란?
  - 파일을 읽고 쓰는 과정처럼 데이터를 입출력하는 것
  - 데이터가 연속적으로 흐른다는 특징
  - 키보드 -> 운영체제 -> 디스플레이
    - stdin
    - stdout
    - stderr
    - out/err 다른 방식으로 (루트로) 출력된다.

  - 리다이렉션(redirection)이란?
    - 입출력 방향을 다른 곳으로 바꾼 
    - 키보드에서 입력을 받지 않고 파일에서 받는 것
    - 디스플레이 -> 파일로 쓰는
    ex) ls -l을 파일로 저장한다.

  - 셸의 역할이다. (운영체제와 파일을 연결하는 작업)


  1) 출력 리다이렉션
    - 출력 내용을 표준 출력이 아닌 파일로 보내 저장하는 것
    - > (명령 끝에씀),  syntax:명령 > 파일이름
    ex)  grep Perl animals.txt > perl.txt


    ##cat 
      - concatenate : "연속"으로 이어 붙인다.
      - cat 파일이름1, 2, 3, ....
        - 파일 1 + 2 + 3....
        - 파일 1 2...
      - 하나 이상의 파일을 다른 여러 종류의 파일과 연결할 때 많이 사용한다.
          - 파일 복사, 합침..
          - 추가 >> (두번사용)
      
          
  2) 입력 리다이렉션
    - 명령 < 파일
    
    ex)
    - wc animals.txt : 포그램이 파일의 존재를 알고 있음.
    - wc < animals.txt : 리다이렉션 때문에 프로그램이 파일 존재 모름

  3) 리다이렉션이 불가능한 출력
    - 표준오류는 리다이렉션이 불가능하다.
    - 아예 불가능하지는 않음
    ex) cp non.txt file.txt 2> result.txt
    - 단 '2>'를 사용하면 리다이렉션이 가능하다.
    - 2>> : 
    - 표준 출력과 오류 같이 리다이렉션하려면? &> 
      ex) 존재하는 파일과 존재하지 않는 파일 모두 읽어서 새로운 파일을 만들자.
      line1.txt non.txt -> line2.txt 
      --> 모두 리다이렉션 해라.
      cat line1.txt non.txt &> line2.txt

  4) 입출력 모두 다 같이
    - 명령 < 입력 > 출력파일
    Q. animals.txt에서 Perl이 있는 라인의 글자(character) 수 세고 결과를 파일로  (result). 입력도 리다이렉션 (한번에)


2. Escape Letters
  - 특정 문자가 가지고 있는 기능을 차단하게 해주는 기능
    ex) \\n, \\t, $
  - \ (역슬래시, 백슬래시)
  - \$HOME (home 변수 기능을 꺼버림) --> 출력하면 $HOME 그대로 출력됨


  ex) 명령 i have a cat (하나의 문자열로 표현) 
    1) ''
      - 제일 강력
      - 안에 있는 모든 기능 해제
       echo 'this  is a directory : $HOME'
       출력 : $HOME (문자 그대로)
       
    2) ""
      - 일부 기능은 해제하지 않는다.
      echo "this  is a directory : $HOME"
      출력 : /home/runner
      
    3) \
      - 일부분을 지정해서 기능해제 (문자 그대로 읽게 함)

      - 큰 따옴표안에 큰 따옴표를 사용하려면?
      \필요
      echo ""home sweet home" (x)
      echo ""home sweet home\"" (o)
      - 명령 줄 바꿔쓰기할 때 많이 쓴다.
      |\ (백슬레시 같은라인이라고 인식, 읽기 편하게 하기 위함)
      ||||(파이프라인이 많아짐)

      cut -c animals.txt\
          |grep...\
          |head.....
      
- 별명 무효화 가능(저번 시간) 

  \기능
  alias grep = "grep -w"
  |grep (\grep)시 기존 별명 사용가능

  
3. 검색경로
  - /usr/bin
  - $PATH 
    : 기준으로 출력 (지금 내용으로 불가능)
  - tr <A> <B> : A -> B로 변경함.
  - 우리가 사용하는 프로그램이 저장되어 있는 경로
  - 셀이 검색 경로를 순차적으로 순회하며 프로그램을 가져온다.
  - 검색 경로 확인 명령 : which, type
    - type은 검색경로 뿐만아니라 더 넓은 범위에서 경로 조회
    (별명까지)
    - 별명이 검색경로를 우선한다. (먼저 검색)

4. 초기화파일
  - shell environment
  - 초기화파일
  - 'ls -a $HOME' # -a : 숨겨진 파일까지 모두 출력
  - $HOME/.bashrc (내 환경설정이 있다.)
  - vi로 열기 -> 수정 -> 적용
  - source로 적용
  - 사용자가 자주 사용하는 환경 설정을 저장하여 항상 셀을 켤 때마다 적용되도록 한다.

5. 명령히스토리
  - command history
  - 우리가 커맨들인에 입력한 명령들을 셀이 저장해서 가지고 있다.
  - 히스토리를 사용해서 이전 명령을 불러와 다시 재사용하는 기능을 익힌다.


  1) 히스토리 열람
  - history
  - LIFO (last in first out)
  - history 10 (마지막 부터 위로 10개가 나옴)

  Q. 히스토리를 가장 처음부터 1-10개 출력하기 + 한화면에
      history | head |less
  Q. 전체 히스토리에서 echo만 출력하기
      history | grep -w echo
  
  - history -c (모두 지움)


  2) 재사용
    1. 커서링
    2. 히스토리 확장
    3. 중분 검색
    
    1. 커서링 
       - 위아래 키를 사용하여 히스토리 열람
       - 간단하지만 느림
       - 이전 2 - 3개 명령일 경우 사용
       - 입력한 역순으로 이전 명령을 불러옴
       - $HISTSIZE (REPLIT:기본값 1000, 바꿀 수 있음)
       - $HISTSIZE = -1 (무한 저장)

       반복되는 명령은? (같은 명령)
       - $HISTCONTROL (기본값 : ignoredups #  중복되는 명령은 한번만 저장)


       - 모든 명령 히스토리는 $HISTFILE에 저장된다.

    2. 히스토리 확장
     - 특별한 표현식을 활용하는 방법
     - 명령을 가져오고 실행까지함
     - !! : 이전 명령
     - !<명령어> : 가장 마지막에 한 특정 명령 가져와서 실행
     - !70 (히스토리 번호) : 번호를 가져와서 실행
     - !-3 (음수 가능!)

     - 장점 : 쉽다.
     - 단점 : 실행까지 되기때문에 조심할 것
      - :p (실행하지 않고 전에 실행한 명령을 보여줌)

      - !70:p -> !! 


  Q. 이전 명령의 단어(word) 수 세기
      !! | wc -w


    - stdout 으로 활용할 수 있다는 점


  - 파일 삭제할 때
    - !$ : 이전 명령의 마지막 내용(인수)
      - head grades
        rm !$
      - head grades2 ($)
      -alias rm= 'rm -i' 삭제하기 전에 확인하라.

    - !* : 인수 2개 이상일 경우 매칭


  3. 증분 검색
    - ctrl + R
    - enter로 가져옴
    - 나오고 싶으면 esc , ctrl c or j
    
    
    
    -요약
      -명령행 편집 효율적으로 잘하자.
      
       